---
title: 进程管理
createTime: 2025/10/05 23:09:48
permalink: /ComputerFundamentals/lzjwojoh/
---
# 一、进程、线程、调度

默认你知道什么是进程 什么是线程。

***

## 进程的几种状态

1. 运行态

2. 阻塞态

3. 就绪态

在虚拟内存的操作系统中，并不会把所有进程都加载到内存中，所以会有新的状态 **挂起态** 代表进程在磁盘中，还没加载到内存中

挂起态可以分为：

* 阻塞挂起态

* 就绪挂起态

## 进程的控制结构PCB

PCB是一种描述进程的数据结构，一个进程会对应一个唯一的PCB。

PCB中包含了进程的很多信息：

1. 进程的状态

2. 进程的优先级

3. 进程拥有的资源分配清单

PCB是以链表的形式组织在一起的，组成队列的形式

* 就绪队列

* 阻塞队列

**线程是进程当中的一条执行流程。**

## 线程和进程的比较

1. 从概念上来说，进程是资源分配的单位，线程是CPU调度的单位

2. 从资源分配上来说，进程之间相互独立，线程之间只独享寄存器和栈这种必不可少的资源

3. 从切换的开销来看：主要体现在进程切换需要刷掉TLB，同一个进程中的线程切换则不用

## 线程的种类

用户级线程：

1. 进程自己进行线程管理，操作系统是不知道这些线程的，只知道进程的状态。

2. 优点：不需要切换到内核态，速度快

3. 缺点：其他线程无法打断正在运行的线程，容易让整个进程都阻塞住。

内核级线程：

1. 内核级线程由操作系统管理

2. 优点：一个线程阻塞，其他线程还有机会正常工作

3. 缺点：需要切换内核态，开销大

## Linux中的调度

虽然说是进程的调度，但其实对于Linux的调度器，其调度的基本单位是还是线程。

**Linux实现的线程的基本方式都是轻量级进程LWP，可以共享一个进程的资源。**

因此对于多线程的进程，每个线程都可以被调度器调度。

对于所有进程，都会有一个主线程，这也是调度器调度的对象。

所以调度的基本单位还是线程。

### 调度算法

主要分为抢占式和非抢占式两种：

* 非抢占式：&#x20;

  * 先来先服务

  * 最短作业优先

* 抢占式：&#x20;

  * 时间片轮转法

# 二、多进程、多线程、锁

## 多进程直接的通信机制

内核提供一些通信的方式，比如管道和消息队列，但都需要做数据的拷贝和os状态切换，都比较慢，开销比较大。

最快的通信机制是共享内存，不需要系统调用和拷贝数据，但也会带来共享资源的问题。所以可以用信号量Semaphore来解决，也就是所谓PV操作，可以实现访问的互斥，进程的同步。

Signal信号和Semaphore信号量不同，是异步通信机制，比如说kill -x 传入的x就是Signal

不同主机间的通信可以用Socket通信

## 死锁相关

### 死锁的四个条件

1. 互斥条件：一个资源同时只能由一个进程获取

2. 持有等待：一个进程在等待资源的时候不会释放自己持有的资源

3. 环路等待：两个进程获取资源的顺序构成了环

4. 不可剥夺：进程拥有的资源不会被剥夺走

### 避免死锁的发生

破坏四个条件中的任何一个都可以，一般最常见并且可行的就是使用资源有序分配法，破坏环路等待条件。

不同进程在获取资源的时候，按照一个相同的顺序去一个一个申请。

## 互斥锁与自旋锁

是最底层的两种锁。

### 互斥锁

互斥锁加锁失败后，线程会释放CPU给其他线程，自己会阻塞住。这个阻塞是由操作系统内核实现的，会把线程置为sleep状态，等到锁释放的时候，内核会在合适的时机唤醒线程，当其成功获取锁的时候，可以继续执行。

当获取锁失败的时候，会从用户态进入内核态，会带来两次系统切换的成本，虽然说线程的系统切换成本低，但仍然还是需要一定时间的。

因此，如果锁住的代码执行很快，可能比上下文切换时间都要快，这时候就可以不用互斥锁，选用自旋锁。

### 自旋锁

通过CPU提供的CAS函数，在用户态完成加锁和释放操作，不会产生线程上下文切换

CAS函数：先查看锁状态，如果是空闲的就把锁设为当前线程私有。

如果CAS加锁失败，线程会一直自旋，忙等待，会一直进行CAS尝试，直到拿到锁，简单的实现方式就是while循环。需要注意的是，自旋的线程永远不会主动放弃CPU。

自旋锁锁状态中心化，竞争激烈时，可能会导致多个CPU的高速缓存频繁同步，拖慢CPU效率。并且可能会出现锁饥饿问题。

### CLH锁

CLH 锁是对自旋锁的一种改进。

首先它将线程组织成一个队列，保证先请求的线程先获得锁，避免了饥饿问题。

其次锁状态去中心化，让每个线程在不同的状态变量中自旋，这样当一个线程释放它的锁时，只能使其后续线程的高速缓存失效，缩小了影响范围，从而减少了 CPU 的开销。

CLH 锁数据结构很简单，类似一个链表队列，所有请求获取锁的线程会排列在链表队列中，自旋访问队列中前一个节点的状态。当一个节点释放锁时，只有它的后一个节点才可以得到锁。CLH锁没有显式的维护队列中的next和prev指针变量。

因此，CLH锁：

* 性能比自旋锁好

* 公平锁

* 实现简单

* 扩展性强

同时仍存在缺点：

* 自旋操作，CPU负担大

* 功能单一

### AQS锁

AQS基于CLH进行改造，首先就是把自旋操作改成了阻塞操作。

并且做了三方面的扩展：

* 扩展每个节点的状态

* 显式的维护prev、next

* 辅助gc的一些操作

## 悲观锁和乐观锁

悲观锁：悲观锁认为出现共享资源的冲突的可能性高，所以在访问共享资源之前都要上锁。

乐观锁：假定冲突的概率很低，在提交修改的时候判断资源是不是被修改过。是无锁的。

## 可重入锁

线程可以再次获取自己的内部锁

## 公平与非公平锁

对公平锁来说，先申请的线程会先获取到，非公平锁则是后申请的线程可能先拿到锁，随机或者按照某种优先级排序的，性能好，但是可能会导致有的线程永远拿不到锁

## 可中断锁和不可中断锁

获取锁的过程中，是否可以被中断，lockInterruptibly之后，这个线程是可以被中断的。


## 贡献者

<div class="contributors-list" style="display: flex; gap: 20px; flex-wrap: wrap; margin-top: 20px;">
  <!-- 贡献者 1 -->    
  <div style="text-align: center;">
    <img src="https://avatars.githubusercontent.com/u/94302726?v=4" alt="魏知乐" style="width: 80px; border-radius: 50%;" />
    <p style="margin-top: 8px;"><a href="https://github.com/spaceluke" target="_blank">魏知乐</a></p>
  </div>

</div>