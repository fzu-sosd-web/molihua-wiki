<!doctype html><html lang="zh-CN"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="generator" content="VuePress 2.0.0-rc.24" /><meta name="theme" content="VuePress Theme Plume 1.0.0-rc.164" /><script id="check-mac-os">document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><script id="check-dark-mode">;(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;const isDark = um === 'dark' || (um !== 'light' && sm);document.documentElement.dataset.theme = isDark ? 'dark' : 'light';})();</script><link rel="icon" type="image/svg+xml" href="/molihua-wiki/SOSD.png"><title>调试理论 | SOSD Molihua</title><meta name="description" content="Knowledge Repository"><link rel="preload" href="/molihua-wiki/assets/style-DfN5sYUi.css" as="style"><link rel="stylesheet" href="/molihua-wiki/assets/style-DfN5sYUi.css"><link rel="modulepreload" href="/molihua-wiki/assets/app-D5tjPIRP.js"><link rel="modulepreload" href="/molihua-wiki/assets/index.html-MTa162xW.js"></head><body><div id="app"><!--[--><!--[--><div class="theme-plume vp-layout" vp-container data-v-f73ca3da><!--[--><!--[--><!--]--><!--[--><span tabindex="-1" data-v-17e3d305></span><a href="#VPContent" class="vp-skip-link visually-hidden" data-v-17e3d305> Skip to content </a><!--]--><!----><header class="vp-nav" data-v-f73ca3da data-v-e98a6132><div class="vp-navbar" vp-navbar data-v-e98a6132 data-v-2c31ea5e><div class="wrapper" data-v-2c31ea5e><div class="container" data-v-2c31ea5e><div class="title" data-v-2c31ea5e><div class="vp-navbar-title has-sidebar" data-v-2c31ea5e data-v-1a4f50af><a class="vp-link link no-icon title" href="/molihua-wiki/" data-v-1a4f50af><!--[--><!--[--><!--]--><!--[--><!--[--><!--[--><img class="vp-image dark logo" style="" src="/molihua-wiki/./SOSD.svg" alt data-v-480e858a><!--]--><!--[--><img class="vp-image light logo" style="" src="/molihua-wiki/./SOSD.svg" alt data-v-480e858a><!--]--><!--]--><!--]--><span data-v-1a4f50af>SOSD Molihua</span><!--[--><!--]--><!--]--><!----></a></div></div><div class="content" data-v-2c31ea5e><div class="content-body" data-v-2c31ea5e><!--[--><!--]--><div class="vp-navbar-search search" data-v-2c31ea5e><div class="search-wrapper" data-v-97535d1e><!----><div id="local-search" data-v-97535d1e><button type="button" class="mini-search mini-search-button" aria-label="搜索文档" data-v-97535d1e><span class="mini-search-button-container"><span class="mini-search-search-icon vpi-mini-search" aria-label="search icon"></span><span class="mini-search-button-placeholder">搜索文档</span></span><span class="mini-search-button-keys"><kbd class="mini-search-button-key"></kbd><kbd class="mini-search-button-key">K</kbd></span></button></div></div></div><!--[--><!--]--><nav aria-labelledby="main-nav-aria-label" class="vp-navbar-menu menu" data-v-2c31ea5e data-v-d43c1732><span id="main-nav-aria-label" class="visually-hidden" data-v-d43c1732>Main Navigation</span><!--[--><!--[--><a class="vp-link link navbar-menu-link" href="/molihua-wiki/" tabindex="0" data-v-d43c1732 data-v-d4acf911><!--[--><!----><span data-v-d4acf911>首页</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/molihua-wiki/Molihua/" tabindex="0" data-v-d43c1732 data-v-d4acf911><!--[--><!----><span data-v-d4acf911>茉莉花</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/molihua-wiki/LearningRoute/" tabindex="0" data-v-d43c1732 data-v-d4acf911><!--[--><!----><span data-v-d4acf911>学习路线</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/molihua-wiki/ComputerFundamentals/" tabindex="0" data-v-d43c1732 data-v-d4acf911><!--[--><!----><span data-v-d4acf911>计算机内功</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/molihua-wiki/About/" tabindex="0" data-v-d43c1732 data-v-d4acf911><!--[--><!----><span data-v-d4acf911>关于我们</span><!----><!--]--><!----></a><!--]--><!--]--></nav><!--[--><!--]--><div class="vp-flyout vp-navbar-translations translations" data-v-2c31ea5e data-v-0d45479b data-v-86530b6c><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="选择语言" data-v-86530b6c><span class="text" data-v-86530b6c><!----><span class="vpi-languages option-icon" data-v-86530b6c></span><!----><!----><span class="vpi-chevron-down text-icon" data-v-86530b6c></span></span></button><div class="menu" data-v-86530b6c><div class="vp-menu" data-v-86530b6c data-v-709dc2b1><!----><!--[--><!--[--><div class="items" data-v-0d45479b><p class="title" data-v-0d45479b>简体中文</p><!--[--><div class="vp-menu-link" data-v-0d45479b data-v-1ff1855f><a class="vp-link link" href="/molihua-wiki/en/" data-v-1ff1855f><!--[--><!----> English <!----><!--]--><!----></a></div><!--]--></div><!--]--><!--]--></div></div></div><div class="vp-navbar-appearance appearance" data-v-2c31ea5e data-v-a295abf6><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-a295abf6 data-v-596c25a9 data-v-7eb32327><span class="check" data-v-7eb32327><span class="icon" data-v-7eb32327><!--[--><span class="vpi-sun sun" data-v-596c25a9></span><span class="vpi-moon moon" data-v-596c25a9></span><!--]--></span></span></button></div><div class="vp-social-links vp-navbar-social-links social-links" data-v-2c31ea5e data-v-ad52545c data-v-40bac536><!--[--><a class="vp-social-link no-icon" href="https://github.com/fzu-sosd-web/molihua-wiki" aria-label="github" target="_blank" rel="noopener" data-v-40bac536 data-v-67b21932><span class="vpi-social-github" /></a><!--]--></div><div class="vp-flyout vp-navbar-extra extra" data-v-2c31ea5e data-v-652282fd data-v-86530b6c><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-86530b6c><span class="vpi-more-horizontal icon" data-v-86530b6c></span></button><div class="menu" data-v-86530b6c><div class="vp-menu" data-v-86530b6c data-v-709dc2b1><!----><!--[--><!--[--><!----><div class="group" data-v-652282fd><div class="item appearance" data-v-652282fd><p class="label" data-v-652282fd>外观</p><div class="appearance-action" data-v-652282fd><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-652282fd data-v-596c25a9 data-v-7eb32327><span class="check" data-v-7eb32327><span class="icon" data-v-7eb32327><!--[--><span class="vpi-sun sun" data-v-596c25a9></span><span class="vpi-moon moon" data-v-596c25a9></span><!--]--></span></span></button></div></div></div><div class="group" data-v-652282fd><div class="item social-links" data-v-652282fd><div class="vp-social-links social-links-list" data-v-652282fd data-v-40bac536><!--[--><a class="vp-social-link no-icon" href="https://github.com/fzu-sosd-web/molihua-wiki" aria-label="github" target="_blank" rel="noopener" data-v-40bac536 data-v-67b21932><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="vp-navbar-hamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="nav-screen" data-v-2c31ea5e data-v-2b50024d><span class="container" data-v-2b50024d><span class="top" data-v-2b50024d></span><span class="middle" data-v-2b50024d></span><span class="bottom" data-v-2b50024d></span></span></button></div></div></div></div><div class="divider" data-v-2c31ea5e><div class="divider-line" data-v-2c31ea5e></div></div></div><!----></header><div class="vp-local-nav reached-top" data-v-f73ca3da data-v-3944d8e8><button class="menu" aria-expanded="false" aria-controls="SidebarNav" data-v-3944d8e8><span class="vpi-align-left menu-icon" data-v-3944d8e8></span><span class="menu-text" data-v-3944d8e8>Menu</span></button><div class="vp-local-nav-outline-dropdown" style="--vp-vh:0px;" data-v-3944d8e8 data-v-4114a62c><button data-v-4114a62c>返回顶部</button><!----></div></div><aside class="vp-sidebar" vp-sidebar data-v-f73ca3da data-v-95211354><div class="curtain" data-v-95211354></div><nav id="SidebarNav" class="nav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-95211354><span id="sidebar-aria-label" class="visually-hidden" data-v-95211354> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-473fd05b><section class="vp-sidebar-item sidebar-item level-0 has-active" data-v-473fd05b data-v-12048f0f><!----><div data-v-12048f0f data-v-12048f0f><div class="items" data-v-12048f0f><!--[--><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-12048f0f data-v-12048f0f><div class="item" data-v-12048f0f><div class="indicator" data-v-12048f0f></div><!----><a class="vp-link link link" href="/molihua-wiki/ComputerFundamentals/wmbrh8qr/" data-v-12048f0f><!--[--><p class="text" data-v-12048f0f><span data-v-12048f0f>内存管理</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-12048f0f data-v-12048f0f><div class="item" data-v-12048f0f><div class="indicator" data-v-12048f0f></div><!----><a class="vp-link link link" href="/molihua-wiki/ComputerFundamentals/gcr4s2zn/" data-v-12048f0f><!--[--><p class="text" data-v-12048f0f><span data-v-12048f0f>文件系统和IO</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-12048f0f data-v-12048f0f><div class="item" data-v-12048f0f><div class="indicator" data-v-12048f0f></div><!----><a class="vp-link link link" href="/molihua-wiki/ComputerFundamentals/b2qyfv5n/" data-v-12048f0f><!--[--><p class="text" data-v-12048f0f><span data-v-12048f0f>调试理论</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-12048f0f data-v-12048f0f><div class="item" data-v-12048f0f><div class="indicator" data-v-12048f0f></div><!----><a class="vp-link link link" href="/molihua-wiki/ComputerFundamentals/lzjwojoh/" data-v-12048f0f><!--[--><p class="text" data-v-12048f0f><span data-v-12048f0f>进程管理</span><!----></p><!--]--><!----></a><!----></div><!----></div><!--]--></div></div></section></div><!--]--><!--[--><!--]--></nav></aside><!--[--><div id="VPContent" vp-content class="vp-content has-sidebar" data-v-f73ca3da data-v-b2beaca7><div class="vp-doc-container has-sidebar has-aside" data-v-b2beaca7 data-v-23f6ad98><!--[--><!--]--><div class="container" data-v-23f6ad98><div class="aside" vp-outline data-v-23f6ad98><div class="aside-curtain" data-v-23f6ad98></div><div class="aside-container" data-v-23f6ad98><div class="aside-content" data-v-23f6ad98><div class="vp-doc-aside" data-v-23f6ad98 data-v-5976474c><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="vp-doc-aside-outline" role="navigation" data-v-5976474c data-v-aa56eba0><div class="content" data-v-aa56eba0><div class="outline-marker" data-v-aa56eba0></div><div id="doc-outline-aria-label" aria-level="2" class="outline-title" role="heading" data-v-aa56eba0><span data-v-aa56eba0>此页内容</span><span class="vpi-print icon" data-v-aa56eba0></span></div><ul class="root" data-v-aa56eba0 data-v-3e6b023c><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-5976474c></div><!--[--><!--]--></div></div></div></div><div class="content" data-v-23f6ad98><div class="content-container" data-v-23f6ad98><!--[--><!--]--><main class="main" data-v-23f6ad98><nav class="vp-breadcrumb" data-v-23f6ad98 data-v-1ae4ad7a><ol vocab="https://schema.org/" typeof="BreadcrumbList" data-v-1ae4ad7a><!--[--><li property="itemListElement" typeof="ListItem" data-v-1ae4ad7a><a class="vp-link link breadcrumb" href="/molihua-wiki/" property="item" typeof="WebPage" data-v-1ae4ad7a><!--[-->首页<!--]--><!----></a><span class="vpi-chevron-right" data-v-1ae4ad7a></span><meta property="name" content="首页" data-v-1ae4ad7a><meta property="position" content="1" data-v-1ae4ad7a></li><li property="itemListElement" typeof="ListItem" data-v-1ae4ad7a><a class="vp-link link breadcrumb current" href="/molihua-wiki/ComputerFundamentals/b2qyfv5n/" property="item" typeof="WebPage" data-v-1ae4ad7a><!--[-->调试理论<!--]--><!----></a><!----><meta property="name" content="调试理论" data-v-1ae4ad7a><meta property="position" content="2" data-v-1ae4ad7a></li><!--]--></ol></nav><!--[--><!--]--><!--[--><h1 class="vp-doc-title page-title" data-v-ba8d1a1e><!----> 调试理论 <!----></h1><div class="vp-doc-meta" data-v-ba8d1a1e><!--[--><!--]--><p class="reading-time" data-v-ba8d1a1e><span class="vpi-books icon" data-v-ba8d1a1e></span><span data-v-ba8d1a1e>约 2256 字</span><span data-v-ba8d1a1e>大约 8 分钟</span></p><!----><!--[--><!--]--><p class="create-time" data-v-ba8d1a1e><span class="vpi-clock icon" data-v-ba8d1a1e></span><span data-v-ba8d1a1e>2025-10-05</span></p></div><!--]--><!--[--><!--]--><div class="_ComputerFundamentals_b2qyfv5n_ external-link-icon-enabled vp-doc plume-content" vp-content data-v-23f6ad98><!--[--><!--]--><div data-v-23f6ad98><blockquote><p>来自蒋炎岩老师的OS2024Spring课程</p><ul><li><a href="https://jyywiki.cn/OS/2024/lect8.md" target="_blank" rel="noopener noreferrer">Yanyan&#39;s Wiki (jyywiki.cn)</a></li><li><a href="https://www.bilibili.com/video/BV16p421U7fk" target="_blank" rel="noopener noreferrer">08-调试理论与实践 (Fault, Error, Failure；调试一切)【南京大学2024操作系统】</a></li></ul></blockquote><h2 id="调试心态" tabindex="-1"><a class="header-anchor" href="#调试心态"><span>调试心态</span></a></h2><h3 id="公理-1-机器永远是对的" tabindex="-1"><a class="header-anchor" href="#公理-1-机器永远是对的"><span>公理 1：<strong>机器永远是对的</strong></span></a></h3><ul><li>CPU: “无情的、执行指令的机器”</li><li>Crash, Wrong Answer, 虚拟机神秘重启 <ul><li>99.9999% 是自己的问题</li><li>有亿点点概率是编译器错了 (但你可以知道)</li><li>有亿点点点点概率是处理器错了 (你也可以知道)</li></ul></li></ul><h3 id="公理-2-未测代码永远是错的" tabindex="-1"><a class="header-anchor" href="#公理-2-未测代码永远是错的"><span>公理 2：<strong>未测代码永远是错的</strong></span></a></h3><ul><li>未反复测试过的代码都是错的 <ul><li>快速地测试→测试框架&amp;&amp;测试用例</li></ul></li><li>你以为最不可能出 bug 的地方，往往 bug 就在那躺着</li></ul><h2 id="why-is-there-bug" tabindex="-1"><a class="header-anchor" href="#why-is-there-bug"><span>Why is there bug?</span></a></h2><blockquote><p>每个鏖战的夜晚都会发出的怒吼QAQ</p></blockquote><h3 id="软件-的两层含义" tabindex="-1"><a class="header-anchor" href="#软件-的两层含义"><span>“软件” 的两层含义</span></a></h3><ul><li>人类需求在信息世界的<strong>投影</strong><ul><li>理解错需求 → bug</li></ul></li><li>计算过程的精确 (数学) 描述 <ul><li>实现错误 → bug</li></ul></li></ul><h3 id="调试为什么困难" tabindex="-1"><a class="header-anchor" href="#调试为什么困难"><span>调试为什么困难？</span></a></h3><ul><li>Bug 的触发经历了漫长的过程</li><li>可观测的现象未必能直接对应到 root cause 上</li></ul><h3 id="fault-error-和-failure" tabindex="-1"><a class="header-anchor" href="#fault-error-和-failure"><span>Fault, Error, 和 Failure</span></a></h3><p>需求 → 设计 → 代码 (<em>[起因]</em> <strong>Fault/bug</strong>) → 执行 (<em>[中间因素]</em> <strong>Error</strong>) → 失败 (<em>[结果]</em> <strong>Failure</strong>)</p><ul><li><p>我们只能观测到 failure (可观测的结果中的错误)</p></li><li><p>我们可以检查状态的正确性 (但非常费时)</p></li><li><p>无法预知 bug 在哪里 (每一行 “看起来” 都挺对的)</p><ul><li><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> j </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> j </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> n</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        ...    </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p>人总是 “默认” (不默认，浪费的时间就太多了)</p></li></ul><h2 id="调试理论" tabindex="-1"><a class="header-anchor" href="#调试理论"><span>调试理论</span></a></h2><blockquote><p><mark>调试理论</mark>：如果我们能判定任意程序状态的正确性，那么给定一个 failure，我们可以通过二分查找定位到第一个 error 的状态，此时的代码就是 fault (bug)。</p></blockquote><h3 id="推论" tabindex="-1"><a class="header-anchor" href="#推论"><span>推论</span></a></h3><ul><li>为什么我们喜欢 “单步调试”？ <ul><li>从一个假定正确的状态出发</li><li>每个语句的行为有限，容易判定是否是 error</li></ul></li><li>为什么调试理论看起来很没用？ <ul><li><strong>“判定状态正确” 非常困难</strong></li><li>(是否在调试 DP 题/图论算法时陷入时间黑洞？)</li></ul></li></ul><h3 id="调试-观察状态机执行-trace-的某个侧面" tabindex="-1"><a class="header-anchor" href="#调试-观察状态机执行-trace-的某个侧面"><span>调试 = 观察状态机执行 (trace) 的某个侧面</span></a></h3><blockquote><p>程序的运行就是一个状态机</p></blockquote><ul><li>缩小错误状态 (error) 可能产生的位置</li><li>提出假设，作出验证</li></ul><h3 id="观察状态机执行的两个基本工具" tabindex="-1"><a class="header-anchor" href="#观察状态机执行的两个基本工具"><span>观察状态机执行的两个基本工具</span></a></h3><ul><li>printf → 自定义 log 的 trace <ul><li>灵活可控、能快速定位问题大概位置、适用于大型软件 <ul><li>用多个log将程序的运行状态分隔, 进行bug定位</li></ul></li><li>无法精确定位、大量的 logs 管理起来比较麻烦</li></ul></li><li>gdb → 指令/语句级 trace <ul><li>精确、指令级定位、任意查看程序内部状态</li><li>耗费大量时间</li></ul></li></ul><h3 id="如何理解调试理论" tabindex="-1"><a class="header-anchor" href="#如何理解调试理论"><span>如何理解调试理论</span></a></h3><p>调试理论给了大家在遇到 “任何问题” 时候 self-check 的列表：</p><blockquote><p>记住: <strong>机器永远是对的</strong></p></blockquote><ol><li>是怎样的程序 (状态机) 在运行？</li><li>我们遇到了怎样的 failure？</li><li>我们能从状态机的运行中从易到难得到什么信息？</li><li>如何二分检查这些信息和 error 之间的关联？</li></ol><h2 id="调试一切" tabindex="-1"><a class="header-anchor" href="#调试一切"><span>调试一切</span></a></h2><h3 id="computer-world-一切皆可调试" tabindex="-1"><a class="header-anchor" href="#computer-world-一切皆可调试"><span>Computer world: 一切皆可调试</span></a></h3><h4 id="计算机随时随地都在拒绝你" tabindex="-1"><a class="header-anchor" href="#计算机随时随地都在拒绝你"><span>计算机随时随地都在拒绝你</span></a></h4><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">bash:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> curl:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> command</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> not</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> found</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">fatal</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> error:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">sys/cdefs.h</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> No</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> such</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> file</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> or</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> directory</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> #include &lt;sys/cdefs.h&gt; </span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">/usr/bin/ld:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> cannot</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> find</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -lgcc:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> No</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> such</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> file</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> or</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> directory</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">make[2]:</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> ***</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> No</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> such</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> file</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> or</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> directory.</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">  Stop.</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> Makefile:31:</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> recipe</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> for</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> target</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">run</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> failed</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>万能方法：假设你遇到的问题是别人也遇到的</strong></p><ul><li>但如果这是一个全新的问题？</li></ul><h4 id="程序-计算机系统-状态机" tabindex="-1"><a class="header-anchor" href="#程序-计算机系统-状态机"><span>程序 = 计算机系统 = 状态机</span></a></h4><blockquote><p>机器永远是对的</p></blockquote><p>UNIX 世界里你做任何事情都是在**<mark>编程</mark>**</p><ul><li>“用编程语言把脑中所想传达给电脑” <ul><li>命令行的命令就是编程 → 一个简短的shell脚本</li><li>最开始使用图形化界面运行/debug也是编程 → 可以发现vscode只是代替你执行了一些命令行语句</li></ul></li><li>刚才的问题都可以看成是程序/输入/配置有 bug</li></ul><h4 id="调试理论可以用于解决任何-问题" tabindex="-1"><a class="header-anchor" href="#调试理论可以用于解决任何-问题"><span>调试理论可以用于解决任何 “问题”</span></a></h4><ul><li>curl: command not found</li><li><code>&#39;sys/cdefs.h&#39;</code>: No such file or directory</li><li>Makefile:31: recipe for target &#39;run&#39; failed</li></ul><h3 id="使用调试理论" tabindex="-1"><a class="header-anchor" href="#使用调试理论"><span>使用调试理论</span></a></h3><h4 id="fault-程序-输入-配置错-→-error-→-failure-可观测" tabindex="-1"><a class="header-anchor" href="#fault-程序-输入-配置错-→-error-→-failure-可观测"><span>Fault (程序/输入/配置错) → Error → Failure (可观测)</span></a></h4><ul><li>大部分 Error 和 Failure 都比较接近 <ul><li>出错时，使用 perror 打印日志</li></ul></li></ul><h4 id="找不到问题-的原因" tabindex="-1"><a class="header-anchor" href="#找不到问题-的原因"><span>“找不到问题” 的原因</span></a></h4><ul><li><strong>出错原因报告不准确</strong><ul><li>也可能是没看懂</li><li>对于大型项目(如Spring)更是这样, 对于一种Failure有多种可能的Fault, 当STFW时, 很可能会搜到多种不相干的Fault😞</li><li>这个时候把这些报错信息丢给LLM不失为一个好选择😄</li></ul></li><li><strong>程序执行的过程看不到</strong><ul><li>那我们想办法 “看到” 状态机的执行过程就好了！</li></ul></li></ul><h4 id="理解状态机执行-不是-调试-也是-调试" tabindex="-1"><a class="header-anchor" href="#理解状态机执行-不是-调试-也是-调试"><span>理解状态机执行：不是 “调试”，也是 “调试”</span></a></h4><ul><li><code>ssh</code>：使用 <code>-v</code> 选项检查日志</li><li><code>gcc</code>：使用 <code>-v</code> 选项打印各种过程</li><li><code>make</code>：使用 <code>-nB</code> 选项查看完整命令历史</li></ul><h4 id="调试-不仅是-调试器" tabindex="-1"><a class="header-anchor" href="#调试-不仅是-调试器"><span>调试：不仅是 “调试器”</span></a></h4><ul><li>Profiler: <code>perf</code> - “采样” 状态机</li><li>Trace: <code>strace</code> - 追踪系统调用</li></ul><h4 id="例-sys-cdefs-h-no-such-file-or-directory" tabindex="-1"><a class="header-anchor" href="#例-sys-cdefs-h-no-such-file-or-directory"><span>例: &#39;sys/cdefs.h&#39;: No such file or directory</span></a></h4><ul><li>(这看起来是用 <code>perror()</code> 打印出来的！)</li><li>问题分析 <ul><li><code>#include</code> = 复制粘贴，自然会经过路径解析</li><li>明明 <code>/usr/include/x86_64-linux-gnu/sys/cdefs.h</code> 是存在的 (<code>man 1 locate</code>)</li></ul></li></ul><h5 id="两种方法" tabindex="-1"><a class="header-anchor" href="#两种方法"><span>两种方法</span></a></h5><ul><li>日志: 运行时添加 <code>--verbose</code>选项</li><li>strace，直接看访问过的文件！</li></ul><h3 id="调试程序" tabindex="-1"><a class="header-anchor" href="#调试程序"><span>调试程序</span></a></h3><h4 id="gdb-状态机查看器" tabindex="-1"><a class="header-anchor" href="#gdb-状态机查看器"><span>GDB：状态机查看器</span></a></h4><ul><li>允许我们控制执行流、检查状态</li><li>而且原生支持 Python <ul><li>因此拥有众多前端：gdb-gui, cgdb, pwndbg, gdb-dashboard, vscode, ddd, ..</li><li>(我觉得最好用的还是自己按需轻量定制)</li></ul></li></ul><h4 id="使用-gnu-debugger" tabindex="-1"><a class="header-anchor" href="#使用-gnu-debugger"><span>使用 GNU Debugger</span></a></h4><ul><li>GDB: 最常用的命令在<a class="vp-link link" href="/molihua-wiki/./debug-theory.assets/gdb-cheat-sheet.pdf" target="_blank" rel="noreferrer"><!--[-->gdb cheat sheet<!--]--><span class="vpi-external-link"></span></a><ul><li>打印贴在电脑前，调试时候看一遍，很快就大致记住了</li></ul></li></ul><h4 id="我们依旧需要-rtfm" tabindex="-1"><a class="header-anchor" href="#我们依旧需要-rtfm"><span>我们依旧需要 <a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/" target="_blank" rel="noopener noreferrer">RTFM</a></span></a></h4><ul><li>否则我们甚至不知道 gdb 有多强大</li></ul><h4 id="cheat-sheet-里没有的功能" tabindex="-1"><a class="header-anchor" href="#cheat-sheet-里没有的功能"><span>Cheat Sheet 里没有的功能</span></a></h4><ul><li>Text UI (我已经默认启动)</li><li>Stack, optimized code, macros, ...</li><li>Reverse execution</li><li>Record and replay</li><li>Scheduler</li></ul><h2 id="调试理论的应用" tabindex="-1"><a class="header-anchor" href="#调试理论的应用"><span>调试理论的应用</span></a></h2><p><strong>需求 → 设计 → 代码 → Fault → Error → Failure</strong></p><ul><li>“Technical Debt”: 每当你写出不好维护的代码，你都在给你未来的调试/需求变更挖坑 <ul><li>论敏捷开发与💩山代码</li></ul></li></ul><h3 id="调试理论-推论1" tabindex="-1"><a class="header-anchor" href="#调试理论-推论1"><span>调试理论: 推论1</span></a></h3><h4 id="需求-→-设计-→-代码-→-fault-→-error-→-failure" tabindex="-1"><a class="header-anchor" href="#需求-→-设计-→-代码-→-fault-→-error-→-failure"><span><!----> → Error → Failure</span></a></h4><ul><li><strong>写好代码</strong>：不要在写代码的时候忘记需求和设计</li><li>不言自明 (Self-explanatory) <ul><li>能通过字面知道需求 (流程)</li></ul></li><li>不言自证 (Self-evident) <ul><li>能通过字面确认代码和需求一致</li></ul></li></ul><h3 id="一个评判标准" tabindex="-1"><a class="header-anchor" href="#一个评判标准"><span><strong>一个评判标准</strong></span></a></h3><ul><li>AI 是否能正确理解/维护你的代码: <a href="http://git.nju.edu.cn/jyy/toybox" target="_blank" rel="noopener noreferrer">toybox</a></li></ul><blockquote><p>Programs are meant to be read by humans and only incidentally for computers to execute. (Donald E. Knuth)</p><p>程序首先是给人读的, 其次才是给机器去执行</p></blockquote><h3 id="调试理论-推论-2" tabindex="-1"><a class="header-anchor" href="#调试理论-推论-2"><span>调试理论：推论 (2)</span></a></h3><h4 id="需求-→-设计-→-代码-→-fault-→-error-→-failure-1" tabindex="-1"><a class="header-anchor" href="#需求-→-设计-→-代码-→-fault-→-error-→-failure-1"><span>需求 → 设计 → 代码 → <!----> → Failure</span></a></h4><ul><li><strong>做好测试</strong>：未测代码永远是错的 <ul><li>残酷的现实：相信自己写不对代码</li><li>LLM 一样经常犯 “傻” 错</li></ul></li></ul><h4 id="small-scope-hypothesis" tabindex="-1"><a class="header-anchor" href="#small-scope-hypothesis"><span>Small Scope Hypothesis</span></a></h4><blockquote><p>If a system does not have a counterexample (i.e., an error or a bug) for a certain property within a small scope (a limited size or configuration), then it is unlikely to have a counterexample in a larger scope. (Daniel Jackson)</p><p>如果一个系统在有限的范围（有限的大小或配置）内对某个特定属性没有反例（即错误或漏洞），那么它在更大的范围内也不太可能有反例。</p></blockquote><h3 id="调试理论-推论-3" tabindex="-1"><a class="header-anchor" href="#调试理论-推论-3"><span>调试理论：推论 (3)</span></a></h3><h4 id="需求-→-设计-→-代码-→-fault-→-error-→-failure-2" tabindex="-1"><a class="header-anchor" href="#需求-→-设计-→-代码-→-fault-→-error-→-failure-2"><span>需求 → 设计 → 代码 → Fault → <!----></span></a></h4><ul><li>测试的目的: 将隐藏的Fault暴露出来 变成可观测的Failure</li><li><strong>多写断言ASSERT</strong>：把代码中的 “隐藏性质” 写出来 <ul><li>机器总是对的, 但人总可能犯错→在你发现bug前, 描述正确代码应该有的性质, 用断言来表述他们</li><li>Error 暴露的越晚，调试越困难</li><li>追溯导致 assert failure 的变量值 (slice) 通常可以快速定位到 bug</li></ul></li></ul><blockquote><p>“There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies” (Tony Hoare)</p><p>构建软件设计有两种方式：一种方式是让它简单到明显没有缺陷；另一种方式是让它复杂到没有明显的缺陷</p><ul><li><strong>简单到无懈可击</strong>：第一种方法是设计一个极其简单明了的系统，简单到没有任何明显的缺陷或漏洞</li><li><strong>复杂到难以察觉缺陷</strong>：第二种方法是创建一个如此复杂和深奥的设计，以至于缺陷并不明显</li></ul></blockquote><h2 id="贡献者" tabindex="-1"><a class="header-anchor" href="#贡献者"><span>贡献者</span></a></h2><div class="contributors-list" style="display:flex;gap:20px;flex-wrap:wrap;margin-top:20px;"><div style="text-align:center;"><img src="https://avatars.githubusercontent.com/u/76905040?v=4" alt="张江杰" style="width:80px;border-radius:50%;"><p style="margin-top:8px;"><a href="https://github.com/yJader" target="_blank">张江杰</a></p></div></div></div><!----><!----><!----></div></main><footer class="vp-doc-footer" data-v-23f6ad98 data-v-7138e2cb><!--[--><!--]--><!----><!----><nav class="prev-next" data-v-7138e2cb><div class="pager" data-v-7138e2cb><a class="vp-link link pager-link prev" href="/molihua-wiki/ComputerFundamentals/gcr4s2zn/" data-v-7138e2cb><!--[--><span class="desc" data-v-7138e2cb>上一页</span><span class="title" data-v-7138e2cb>文件系统和IO</span><!--]--><!----></a></div><div class="pager" data-v-7138e2cb><a class="vp-link link pager-link next" href="/molihua-wiki/ComputerFundamentals/lzjwojoh/" data-v-7138e2cb><!--[--><span class="desc" data-v-7138e2cb>下一页</span><span class="title" data-v-7138e2cb>进程管理</span><!--]--><!----></a></div></nav></footer><!----><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!--]--><button type="button" class="vp-back-to-top" aria-label="back to top" data-v-f73ca3da style="display:none;" data-v-bcf8d9a6><span class="percent" data-allow-mismatch data-v-bcf8d9a6>0%</span><span class="show icon vpi-back-to-top" data-v-bcf8d9a6></span><svg aria-hidden="true" data-v-bcf8d9a6><circle cx="50%" cy="50%" data-allow-mismatch style="stroke-dasharray:calc(0% - 12.566370614359172px) calc(314.1592653589793% - 12.566370614359172px);" data-v-bcf8d9a6></circle></svg></button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="sign down" class="vp-sign-down" aria-hidden="true" data-v-f73ca3da style="display:none;" data-v-900978de><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" data-v-900978de><path d="m19 11l-7 6l-7-6" data-v-900978de></path><path d="m19 5l-7 6l-7-6" opacity="0.6" data-v-900978de></path></g></svg><!----><!--[--><!--]--><!--]--></div><!----><!--]--><!--[--><!--]--><!--]--></div><script type="module" src="/molihua-wiki/assets/app-D5tjPIRP.js" defer></script></body></html>